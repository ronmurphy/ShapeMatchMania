<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Match-3 Game</title>
    <style>
        @keyframes scorePopup {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        @keyframes comboText {
            0% { transform: scale(0.5) translateY(0); opacity: 0; }
            20% { transform: scale(1.2) translateY(-20px); opacity: 1; }
            80% { transform: scale(1) translateY(-40px); opacity: 1; }
            100% { transform: scale(0.8) translateY(-60px); opacity: 0; }
        }

        @keyframes powerupGlow {
            0%, 100% { box-shadow: 0 0 10px currentColor; }
            50% { box-shadow: 0 0 20px currentColor; }
        }

        @keyframes powerupHover {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        @keyframes powerupActivate {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.2); filter: brightness(1.5); }
            100% { transform: scale(1); filter: brightness(1); }
        }

        @keyframes chainLink {
            0% { transform: scale(1) rotate(0deg); }
            100% { transform: scale(1) rotate(360deg); }
        }

        @keyframes powerupReady {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .powerup-item {
            position: relative;
            animation: powerupHover 2s ease-in-out infinite;
        }

        .powerup-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            animation: powerupGlow 1.5s ease-in-out infinite;
            opacity: 0.5;
        }

        .powerup-item.active {
            animation: powerupActivate 0.5s ease-out;
            z-index: 2;
        }

        .powerup-effect-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .chain-link {
            position: absolute;
            width: 30px;
            height: 30px;
            animation: chainLink 1s linear infinite;
        }

        .powerup-ready {
            animation: powerupReady 1s ease-in-out infinite;
            background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 70%);
        }

        .score-popup {
            position: absolute;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: scorePopup 1s ease-out forwards;
            z-index: 100;
        }

        .combo-text {
            position: absolute;
            color: #FFD700;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            pointer-events: none;
            animation: comboText 1.5s ease-out forwards;
            z-index: 100;
            text-align: center;
            width: 200px;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes float {
            0%,
            100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-20px);
            }
        }

        @keyframes explode {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 0.5;
            }
            100% {
                transform: scale(2) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes colorBurst {
            0% {
                filter: brightness(1);
                transform: scale(1);
            }
            50% {
                filter: brightness(1.5);
                transform: scale(1.2);
            }
            100% {
                filter: brightness(1);
                transform: scale(1);
            }
        }

        @keyframes rainbowPulse {
            0% {
                filter: hue-rotate(0deg);
            }
            100% {
                filter: hue-rotate(360deg);
            }
        }

        @keyframes shuffle {
            0% {
                transform: rotate(0deg);
            }
            25% {
                transform: rotate(-30deg);
            }
            75% {
                transform: rotate(30deg);
            }
            100% {
                transform: rotate(0deg);
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden;
        }

        .game-container {
            display: none;
        }

        .game-board {
            display: grid;
            gap: 4px;
            background: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.3s;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .cell:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.15);
        }

        .selected {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .score-container {
            margin: 20px 0;
            font-size: 24px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .progress-container {
            width: 100%;
            max-width: 352px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 100%;
            background: #4fd1c5;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        #powerupDock {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin-top: 15px;
            min-height: 70px;
            align-items: center;
        }

        .powerup-item {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s;
            position: relative;
        }

        .powerup-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            display: none;
            z-index: 100;
        }

        .powerup-item:hover {
            transform: scale(1.1);
        }

        .powerup-item:hover .powerup-tooltip {
            display: block;
        }

        @keyframes swapLeft {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(-44px);
            }
        }

        @keyframes swapRight {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(44px);
            }
        }

        @keyframes swapUp {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-44px);
            }
        }

        @keyframes swapDown {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(44px);
            }
        }

        .swap-left {
            animation: swapLeft 0.3s ease-in-out;
        }

        .swap-right {
            animation: swapRight 0.3s ease-in-out;
        }

        .swap-up {
            animation: swapUp 0.3s ease-in-out;
        }

        .swap-down {
            animation: swapDown 0.3s ease-in-out;
        }

        .background-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: float 3s infinite;
        }

        @keyframes dropIn {
            0% {
                transform: translateY(-500px);
                opacity: 0;
            }
            60% {
                transform: translateY(20px);
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .drop-in {
            animation: dropIn 0.5s ease-out;
        }

        .level-up-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 24px;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0%,
            100% {
                opacity: 0;
            }
            50% {
                opacity: 1;
            }
        }

        button {
            background: #4fd1c5;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        button:hover {
            background: #38b2ac;
        }

        button:disabled {
            background: #2d7c76;
            cursor: not-allowed;
            opacity: 0.7;
        }

        @keyframes rainbowGlow {
            0%, 100% { filter: hue-rotate(0deg) brightness(1.2); }
            50% { filter: hue-rotate(360deg) brightness(1.5); }
        }

        @keyframes starSparkle {
            0%, 100% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
        }

        @keyframes bombPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px rgba(255,0,0,0.5); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px rgba(255,0,0,0.8); }
        }

        .special-rainbow {
            animation: rainbowGlow 2s infinite;
        }

        .special-star {
            animation: starSparkle 1.5s infinite;
        }

        .special-bomb {
            animation: bombPulse 1s infinite;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
        }

        @keyframes particleFade {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes sparkle {
            0%, 100% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1); opacity: 1; }
        }

        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            pointer-events: none;
            animation: sparkle 0.8s ease-out forwards;
        }

        #level-display {
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }

        .level-up-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .game-board {
            display: grid;
            gap: 4px;
            background: rgba(255, 255, 255, 0.15);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            width: fit-content;
            margin: 0 auto;
        }

        .cell {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.3s;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            flex-shrink: 0;
        }

        .score-container {
            margin: 20px 0;
            font-size: 24px;
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
        }

        .game-container {
            display: none;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            padding: 0 20px;
        }

        #powerupDock {
            width: 100%;
            max-width: 600px;
            margin: 15px auto;
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-height: 70px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        @keyframes targetPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px currentColor; }
            50% { transform: scale(1.1); box-shadow: 0 0 20px currentColor; }
        }

        @keyframes chainLink {
            0% { transform: scale(1) rotate(0deg); opacity: 0.7; }
            50% { transform: scale(1.1) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 0.7; }
        }

        @keyframes goldShimmer {
            0% { filter: brightness(1) contrast(1); }
            50% { filter: brightness(1.5) contrast(1.2) saturate(1.5); }
            100% { filter: brightness(1) contrast(1); }
        }

        @keyframes rainbowCycle {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        @keyframes shuffleShake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-15deg); }
            75% { transform: rotate(15deg); }
        }

        @keyframes wildCardGlow {
            0% { box-shadow: 0 0 10px #4CAF50; }
            50% { box-shadow: 0 0 20px #4CAF50, inset 0 0 10px #4CAF50; }
            100% { box-shadow: 0 0 10px #4CAF50; }
        }

        .powerup-active {
            border: 2px solid white;
            animation: targetPulse 1s infinite;
        }

        .powerup-item {
            position: relative;
            overflow: visible;
        }

        .powerup-item::after {
            content: '';
            position: absolute;
            top: -5px;
            right: -5px;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: white;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .powerup-ready::after {
            opacity: 1;
            animation: targetPulse 1s infinite;
        }

        .cell-targetable {
            cursor: crosshair !important;
            animation: targetPulse 1s infinite;
        }

        .cell-chain-ready {
            animation: chainLink 2s infinite;
        }

        .cell-gold-rush {
            animation: goldShimmer 2s infinite;
        }

        .cell-rainbow {
            animation: rainbowCycle 2s linear infinite;
        }

        .cell-shuffle {
            animation: shuffleShake 0.5s infinite;
        }

        .cell-wild-card {
            animation: wildCardGlow 1s infinite;
        }

        .powerup-effect-overlay {
            pointer-events: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
        }

        .chain-link-line {
            position: absolute;
            height: 2px;
            background: rgba(255, 255, 255, 0.5);
            transform-origin: left center;
            pointer-events: none;
        }
    </style>
</head>

<body>
<div id="startMenu">
    <h1>Enhanced Match-3 Game</h1>
    <p>Welcome to an addictive puzzle adventure!<br> Match 3 or more pieces to score points:<br> üé® Same color: +1 point each<br> ‚≠ê Same shape: +1 point each<br> ‚ú® Both match: +3x points bonus!</p>
    <p>üéÆ How to play:<br> ‚Ä¢ Swap adjacent pieces<br> ‚Ä¢ Create matches in any direction<br> ‚Ä¢ Earn powerups and special combos<br> ‚Ä¢ Level up for bigger challenges!</p>
    <button id="readyBtn">Start Game!</button>
</div>

<div class="game-container" id="gameContainer">
    <div class="progress-container">
        <div class="progress-bar" style="width: 0%"></div>
    </div>
    <div class="score-container">
        <div>Score: <span id="score">0</span></div>
        <button id="powerupButton" disabled>Buy Powerup (100pts)</button>
    </div>
    <div id="grid" class="game-board"></div>
    <div id="powerupDock"></div>
</div>

<script>
    class ParticleSystem {
        constructor() {
            this.particles = [];
            this.lastUpdate = Date.now();
            this.startAnimation();
        }

        startAnimation() {
            const animate = () => {
                const now = Date.now();
                const delta = (now - this.lastUpdate) / 1000;
                this.update(delta);
                this.lastUpdate = now;
                requestAnimationFrame(animate);
            };
            animate();
        }

        update(delta) {
            this.particles.forEach((particle, index) => {
                particle.life -= delta;
                if (particle.life <= 0) {
                    particle.element.remove();
                    this.particles.splice(index, 1);
                    return;
                }

                particle.x += particle.vx * delta;
                particle.y += particle.vy * delta;
                particle.vy += 500 * delta; // Gravity
                particle.rotation += particle.rotationSpeed * delta;
                particle.scale -= delta * 0.5;

                particle.element.style.transform =
                    `translate(${particle.x}px, ${particle.y}px)
                 rotate(${particle.rotation}deg)
                 scale(${Math.max(0, particle.scale)})`;
                particle.element.style.opacity = particle.life / particle.initialLife;
            });
        }

        createParticle(x, y, color, shape = null) {
            const element = document.createElement('div');
            element.className = 'particle';

            if (shape) {
                // Create SVG shape particle
                element.appendChild(createSVG(shape, color));
                element.style.width = '20px';
                element.style.height = '20px';
            } else {
                // Create simple circular particle
                element.style.width = '8px';
                element.style.height = '8px';
                element.style.backgroundColor = color;
                element.style.borderRadius = '50%';
            }

            document.body.appendChild(element);

            const particle = {
                element,
                x,
                y,
                vx: (Math.random() - 0.5) * 400,
                vy: -Math.random() * 400 - 100,
                rotation: Math.random() * 360,
                rotationSpeed: (Math.random() - 0.5) * 720,
                scale: 1,
                life: 1 + Math.random(),
                initialLife: 1
            };

            this.particles.push(particle);
            return particle;
        }

        createSparkle(x, y) {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            sparkle.style.left = x + 'px';
            sparkle.style.top = y + 'px';
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 800);
        }

        burstParticles(x, y, color, shape = null, count = 10) {
            for (let i = 0; i < count; i++) {
                this.createParticle(x, y, color, shape);
            }
        }

        createSparkleField(x, y, radius = 50, count = 5) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const sparkleX = x + Math.cos(angle) * radius * Math.random();
                const sparkleY = y + Math.sin(angle) * radius * Math.random();
                this.createSparkle(sparkleX, sparkleY);
            }
        }
    }

    class PowerupEffects {
        constructor() {
            this.overlay = document.createElement('div');
            this.overlay.className = 'powerup-effect-overlay';
            document.body.appendChild(this.overlay);
        }

        clearEffects() {
            this.overlay.innerHTML = '';
        }

        createChainEffect(startCell, endCell) {
            const start = startCell.getBoundingClientRect();
            const end = endCell.getBoundingClientRect();

            const link = document.createElement('div');
            link.className = 'chain-link';
            link.style.left = (start.left + end.left) / 2 + 'px';
            link.style.top = (start.top + end.top) / 2 + 'px';
            link.innerHTML = '‚õìÔ∏è';

            this.overlay.appendChild(link);
            setTimeout(() => link.remove(), 1000);
        }

        highlightPossibleMatches(cells) {
            cells.forEach(cell => {
                const highlight = document.createElement('div');
                highlight.className = 'powerup-ready';
                highlight.style.position = 'absolute';
                const rect = cell.getBoundingClientRect();
                highlight.style.left = rect.left + 'px';
                highlight.style.top = rect.top + 'px';
                highlight.style.width = rect.width + 'px';
                highlight.style.height = rect.height + 'px';
                this.overlay.appendChild(highlight);

                setTimeout(() => highlight.remove(), 2000);
            });
        }
    }

    // Initialize effects
    const powerupEffects = new PowerupEffects();

    // Initialize particle system
    const particleSystem = new ParticleSystem();

    // Updated game constants
    let BOARD_SIZE = 8;
    const SHAPES = ['circle', 'square', 'triangle', 'diamond', 'star', 'hexagon'];
    const COLORS = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
    const MAX_POWERUPS = 6;
    const STARTING_POWERUPS = 3; // New constant
    const POWERUP_COST = 100;
    const LEVEL_UP_SCORE = 500;
    const COMBO_MESSAGES = [
        "Nice!",
        "Great!",
        "Awesome!",
        "Amazing!",
        "Incredible!",
        "Spectacular!",
        "Unbelievable!"
    ];

    const MATCH_TYPES = {
        COLOR: 'color',
        SHAPE: 'shape',
        BOTH: 'both'
    };

    const SPECIAL_TYPES = {
        NORMAL: 'normal',
        RAINBOW: 'rainbow',    // Matches any color
        STAR: 'star',         // Clears row and column
        BOMB: 'bomb'          // Clears 3x3 area
    };

    const MATCH_BONUSES = {
        3: 1,    // Base multiplier for 3-in-a-row
        4: 1.5,  // 50% bonus for 4-in-a-row
        5: 2     // Double points for 5-in-a-row
    };

    // Add these variables to your game state
    let comboCounter = 0;
    let cascadeCounter = 0;
    let highScore = localStorage.getItem('highScore') || 0;

    // Game state variables
    let score = 0;
    let selectedCell = null;
    let gameBoard = [];
    let powerups = [];
    let activePowerup = null;
    let goldRushActive = false;
    let chainModeActive = false;
    let moveCounter = 0;
    let chainMovesLeft = 0;
    let currentLevel = 1;
    const BASE_LEVEL_SCORE = 500;
    let pointsToNextLevel = BASE_LEVEL_SCORE;
    let levelProgress = 0;

    // Enhanced powerup definitions
    const POWERUP_TYPES = [{
        name: 'Bomb',
        description: 'Removes a 3x3 grid of blocks',
        emoji: 'üí£',
        action: (row, col) => {
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const newRow = row + i;
                    const newCol = col + j;
                    if (newRow >= 0 && newRow < BOARD_SIZE &&
                        newCol >= 0 && newCol < BOARD_SIZE) {
                        const cell = document.querySelector(
                            `[data-row="${newRow}"][data-col="${newCol}"]`
                        );
                        cell.style.animation = `explode 0.5s ease-out ${(Math.abs(i) + Math.abs(j)) * 0.1}s`;
                        setTimeout(() => replaceBlock(newRow, newCol), 500);
                    }
                }
            }
            return true;
        }
    }, {
        name: 'Line Clear',
        description: 'Clears entire row and column',
        emoji: '‚ö°',
        action: (row, col) => {
            for (let i = 0; i < BOARD_SIZE; i++) {
                // Clear row
                setTimeout(() => replaceBlock(row, i), i * 50);
                // Clear column
                setTimeout(() => replaceBlock(i, col), i * 50);
            }
            return true;
        }
    }, {
        name: 'Color Bomb',
        description: 'Removes all blocks of the clicked color',
        emoji: 'üé®',
        action: (row, col) => {
            const targetColor = gameBoard[row][col].color;
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameBoard[i][j].color === targetColor) {
                        setTimeout(() => replaceBlock(i, j), (i + j) * 50);
                    }
                }
            }
            return true;
        }
    }, {
        name: 'Shape Bomb',
        description: 'Removes all blocks of the clicked shape',
        emoji: '‚≠ê',
        action: (row, col) => {
            const targetShape = gameBoard[row][col].shape;
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameBoard[i][j].shape === targetShape) {
                        setTimeout(() => replaceBlock(i, j), (i + j) * 50);
                    }
                }
            }
            return true;
        }
    }, {
        name: 'Rainbow',
        description: 'Changes all pieces to random colors',
        emoji: 'üåà',
        action: () => {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.animation = 'rainbowPulse 1s linear';
            });
            setTimeout(() => {
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        gameBoard[i][j].color = COLORS[Math.floor(Math.random() * COLORS.length)];
                    }
                }
                updateBoard();
                cells.forEach(cell => cell.style.animation = '');
            }, 1000);
            return true;
        }
    }, {
        name: 'Shuffle',
        description: 'Randomly rearranges all pieces',
        emoji: 'üîÑ',
        action: () => {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.animation = 'shuffle 0.5s ease-in-out';
            });
            setTimeout(() => {
                for (let i = BOARD_SIZE - 1; i > 0; i--) {
                    for (let j = BOARD_SIZE - 1; j > 0; j--) {
                        const randI = Math.floor(Math.random() * (i + 1));
                        const randJ = Math.floor(Math.random() * (j + 1));
                        const temp = gameBoard[i][j];
                        gameBoard[i][j] = gameBoard[randI][randJ];
                        gameBoard[randI][randJ] = temp;
                    }
                }
                updateBoard();
                cells.forEach(cell => cell.style.animation = '');
            }, 500);
            return true;
        }
    }, {
        name: 'Chain Mode',
        description: 'Next 3 moves can match in any direction with 2x points',
        emoji: '‚õìÔ∏è',
        action: () => {
            chainModeActive = true;
            moveCounter = 3;
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.animation = 'colorBurst 0.5s ease-out';
            });
            setTimeout(() => {
                cells.forEach(cell => cell.style.animation = '');
            }, 500);
            return true;
        }
    }, {
        name: 'Wild Card',
        description: 'Next piece clicked matches everything',
        emoji: 'üÉè',
        action: (row, col) => {
            const clickedPiece = gameBoard[row][col];
            const cells = document.querySelectorAll('.cell');

            // Add animation to all pieces
            cells.forEach(cell => {
                cell.style.animation = 'colorBurst 0.5s ease-out';
            });

            setTimeout(() => {
                // Update game state and visuals
                cells.forEach(cell => {
                    const cellRow = parseInt(cell.dataset.row);
                    const cellCol = parseInt(cell.dataset.col);

                    if (cellRow !== row || cellCol !== col) {
                        // Update game state
                        gameBoard[cellRow][cellCol] = {
                            shape: clickedPiece.shape,
                            color: clickedPiece.color
                        };

                        // Update visual
                        cell.innerHTML = '';
                        cell.appendChild(createSVG(clickedPiece.shape, clickedPiece.color));
                    }

                    // Remove animation
                    cell.style.animation = '';
                });

                // Check for matches after transformation
                setTimeout(checkForMatches, 300);
            }, 500);

            return true;
        }
    }, {
        name: 'Gold Rush',
        description: 'Double points for next 3 moves',
        emoji: 'üí∞',
        action: () => {
            goldRushActive = true;
            moveCounter = 3;
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.animation = 'colorBurst 1s ease-out';
                cell.style.filter = 'brightness(1.5)';
            });
            setTimeout(() => {
                cells.forEach(cell => {
                    cell.style.animation = '';
                    cell.style.filter = '';
                });
            }, 1000);
            return true;
        }
    }];

    // Add updateBoard function
    function updateBoard() {
        const cells = document.querySelectorAll('.cell');
        cells.forEach(cell => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            cell.innerHTML = '';
            cell.appendChild(createSVG(gameBoard[row][col].shape, gameBoard[row][col].color));
        });
    }

    // Create SVG shape
    function createSVG(shape, color) {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", "0 0 100 100");
        svg.style.width = "100%";
        svg.style.height = "100%";

        let path;
        switch (shape) {
            case 'circle':
                path = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                path.setAttribute("cx", "50");
                path.setAttribute("cy", "50");
                path.setAttribute("r", "40");
                break;
            case 'square':
                path = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                path.setAttribute("x", "10");
                path.setAttribute("y", "10");
                path.setAttribute("width", "80");
                path.setAttribute("height", "80");
                break;
            case 'triangle':
                path = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                path.setAttribute("points", "50,10 90,90 10,90");
                break;
            case 'diamond':
                path = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                path.setAttribute("points", "50,10 90,50 50,90 10,50");
                break;
            case 'star':
                path = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                path.setAttribute("points", "50,10 61,40 92,40 67,60 76,90 50,73 24,90 33,60 8,40 39,40");
                break;
            case 'hexagon':
                path = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                path.setAttribute("points", "50,10 90,30 90,70 50,90 10,70 10,30");
                break;
        }
        path.setAttribute("fill", color);
        svg.appendChild(path);
        return svg;
    }

    // Initialize game board
    // Update initializeBoard to enforce consistent sizing
    function initializeBoard(explode = false) {
        const grid = document.getElementById('grid');
        grid.innerHTML = '';
        grid.style.gridTemplateColumns = `repeat(${BOARD_SIZE}, 40px)`;

        // Create new empty game board
        gameBoard = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));

        // Fill board with pieces
        for(let i = 0; i < BOARD_SIZE; i++) {
            for(let j = 0; j < BOARD_SIZE; j++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = i;
                cell.dataset.col = j;

                // Create new piece
                gameBoard[i][j] = {
                    shape: SHAPES[Math.floor(Math.random() * SHAPES.length)],
                    color: COLORS[Math.floor(Math.random() * COLORS.length)]
                };

                if (explode) {
                    cell.style.animation = `explode 0.5s ease-out ${(i + j) * 0.05}s`;
                }

                cell.appendChild(createSVG(gameBoard[i][j].shape, gameBoard[i][j].color));
                cell.addEventListener('click', handleCellClick);
                grid.appendChild(cell);
            }
        }

        // Initialize board without matches
        let attempts = 0;
        const maxAttempts = 100; // Prevent infinite loop
        while(findMatches().length > 0 && attempts < maxAttempts) {
            // Regenerate pieces for matches
            const matches = findMatches();
            matches.forEach(({row, col}) => {
                gameBoard[row][col] = {
                    shape: SHAPES[Math.floor(Math.random() * SHAPES.length)],
                    color: COLORS[Math.floor(Math.random() * COLORS.length)]
                };
            });
            updateBoard();
            attempts++;
        }
    }

    // Function to create special pieces
    function createSpecialPiece(row, col, type) {
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        gameBoard[row][col].special = type;
        cell.classList.add(`special-${type}`);
    }

    // Handle cell clicks
    function handleCellClick(event) {
        const cell = event.currentTarget;
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);

        if (activePowerup) {
            if (activePowerup.action(row, col)) {
                removePowerup(activePowerup);
                activePowerup = null;
                setTimeout(() => {
                    dropPieces();
                    fillEmptySpaces();
                    checkForMatches();
                }, 500);
            }
            return;
        }

        // Handle special piece activation
        if (gameBoard[row][col].special) {
            activateSpecialPiece(row, col);
            return;
        }

        if (!selectedCell) {
            selectedCell = cell;
            cell.classList.add('selected');
        } else {
            const selectedRow = parseInt(selectedCell.dataset.row);
            const selectedCol = parseInt(selectedCell.dataset.col);

            if (isAdjacent(row, col, selectedRow, selectedCol)) {
                swapCells(row, col, selectedRow, selectedCol);
                selectedCell.classList.remove('selected');
                selectedCell = null;

                // Check for matches after swap
                setTimeout(() => {
                    if (!findMatches().length) {
                        // If no matches, swap back
                        swapCells(row, col, selectedRow, selectedCol);
                    } else {
                        processMatches();
                    }
                }, 300);
            } else {
                selectedCell.classList.remove('selected');
                selectedCell = cell;
                cell.classList.add('selected');
            }
        }
    }

    // Function to activate special pieces
    function activateSpecialPiece(row, col) {
        const type = gameBoard[row][col].special;
        const cells = [];

        switch(type) {
            case 'rainbow':
                // Clear all pieces of the same color
                const targetColor = gameBoard[row][col].color;
                for(let i = 0; i < BOARD_SIZE; i++) {
                    for(let j = 0; j < BOARD_SIZE; j++) {
                        if(gameBoard[i][j].color === targetColor) {
                            cells.push({row: i, col: j});
                        }
                    }
                }
                break;

            case 'star':
                // Clear row and column
                for(let i = 0; i < BOARD_SIZE; i++) {
                    cells.push({row: row, col: i}); // Clear row
                    cells.push({row: i, col: col}); // Clear column
                }
                break;

            case 'bomb':
                // Clear 3x3 area
                for(let i = -1; i <= 1; i++) {
                    for(let j = -1; j <= 1; j++) {
                        const newRow = row + i;
                        const newCol = col + j;
                        if(newRow >= 0 && newRow < BOARD_SIZE &&
                            newCol >= 0 && newCol < BOARD_SIZE) {
                            cells.push({row: newRow, col: newCol});
                        }
                    }
                }
                break;
        }

        // Clear all affected cells
        cells.forEach(({row, col}) => {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            cell.style.animation = 'explode 0.5s ease-out';
            setTimeout(() => replaceBlock(row, col), 500);
        });

        // Add bonus points for special piece
        updateScore(score + cells.length * 5);
    }

    // Check if cells are adjacent
    function isAdjacent(row1, col1, row2, col2) {
        return (Math.abs(row1 - row2) === 1 && col1 === col2) ||
            (Math.abs(col1 - col2) === 1 && row1 === row2);
    }

    // Swap cells
    function swapCells(row1, col1, row2, col2) {
        const cell1 = document.querySelector(`[data-row="${row1}"][data-col="${col1}"]`);
        const cell2 = document.querySelector(`[data-row="${row2}"][data-col="${col2}"]`);

        // Add swap animation classes
        if (col1 < col2) {
            cell1.classList.add('swap-right');
            cell2.classList.add('swap-left');
        } else if (col1 > col2) {
            cell1.classList.add('swap-left');
            cell2.classList.add('swap-right');
        } else if (row1 < row2) {
            cell1.classList.add('swap-down');
            cell2.classList.add('swap-up');
        } else {
            cell1.classList.add('swap-up');
            cell2.classList.add('swap-down');
        }

        // Swap the actual pieces
        const temp = gameBoard[row1][col1];
        gameBoard[row1][col1] = gameBoard[row2][col2];
        gameBoard[row2][col2] = temp;

        // Update visual representation after animation
        setTimeout(() => {
            // Remove animation classes
            cell1.classList.remove('swap-left', 'swap-right', 'swap-up', 'swap-down');
            cell2.classList.remove('swap-left', 'swap-right', 'swap-up', 'swap-down');

            // Update visuals
            cell1.innerHTML = '';
            cell2.innerHTML = '';
            cell1.appendChild(createSVG(gameBoard[row1][col1].shape, gameBoard[row1][col1].color));
            cell2.appendChild(createSVG(gameBoard[row2][col2].shape, gameBoard[row2][col2].color));
        }, 300);
    }

    // Find all matches on the board
    function findMatches() {
        const matches = new Set();

        // Check horizontal matches
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE - 2; j++) {
                // Check color matches
                if (gameBoard[i][j].color === gameBoard[i][j + 1].color &&
                    gameBoard[i][j].color === gameBoard[i][j + 2].color) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i},${j + 1}`);
                    matches.add(`${i},${j + 2}`);
                }
                // Check shape matches
                if (gameBoard[i][j].shape === gameBoard[i][j + 1].shape &&
                    gameBoard[i][j].shape === gameBoard[i][j + 2].shape) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i},${j + 1}`);
                    matches.add(`${i},${j + 2}`);
                }
            }
        }

        // Check vertical matches
        for (let i = 0; i < BOARD_SIZE - 2; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                // Check color matches
                if (gameBoard[i][j].color === gameBoard[i + 1][j].color &&
                    gameBoard[i][j].color === gameBoard[i + 2][j].color) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i + 1},${j}`);
                    matches.add(`${i + 2},${j}`);
                }
                // Check shape matches
                if (gameBoard[i][j].shape === gameBoard[i + 1][j].shape &&
                    gameBoard[i][j].shape === gameBoard[i + 2][j].shape) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i + 1},${j}`);
                    matches.add(`${i + 2},${j}`);
                }
            }
        }

        for(let i = 0; i < BOARD_SIZE - 2; i++) {
            for(let j = 0; j < BOARD_SIZE - 2; j++) {
                // Check color matches
                if(gameBoard[i][j].color === gameBoard[i+1][j+1].color &&
                    gameBoard[i][j].color === gameBoard[i+2][j+2].color) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i+1},${j+1}`);
                    matches.add(`${i+2},${j+2}`);

                    // Check for 4 or 5 in a row
                    if(i < BOARD_SIZE - 3 && j < BOARD_SIZE - 3 &&
                        gameBoard[i][j].color === gameBoard[i+3][j+3].color) {
                        matches.add(`${i+3},${j+3}`);
                        if(i < BOARD_SIZE - 4 && j < BOARD_SIZE - 4 &&
                            gameBoard[i][j].color === gameBoard[i+4][j+4].color) {
                            matches.add(`${i+4},${j+4}`);
                            createSpecialPiece(i, j, 'bomb');
                        } else {
                            createSpecialPiece(i, j, 'star');
                        }
                    }
                }

                // Check shape matches
                if(gameBoard[i][j].shape === gameBoard[i+1][j+1].shape &&
                    gameBoard[i][j].shape === gameBoard[i+2][j+2].shape) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i+1},${j+1}`);
                    matches.add(`${i+2},${j+2}`);

                    // Check for 4 or 5 in a row
                    if(i < BOARD_SIZE - 3 && j < BOARD_SIZE - 3 &&
                        gameBoard[i][j].shape === gameBoard[i+3][j+3].shape) {
                        matches.add(`${i+3},${j+3}`);
                        if(i < BOARD_SIZE - 4 && j < BOARD_SIZE - 4 &&
                            gameBoard[i][j].shape === gameBoard[i+4][j+4].shape) {
                            matches.add(`${i+4},${j+4}`);
                            createSpecialPiece(i, j, 'rainbow');
                        }
                    }
                }
            }
        }

        // Check diagonal matches (top-right to bottom-left)
        for(let i = 0; i < BOARD_SIZE - 2; i++) {
            for(let j = 2; j < BOARD_SIZE; j++) {
                // Check color matches
                if(gameBoard[i][j].color === gameBoard[i+1][j-1].color &&
                    gameBoard[i][j].color === gameBoard[i+2][j-2].color) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i+1},${j-1}`);
                    matches.add(`${i+2},${j-2}`);

                    // Check for 4 or 5 in a row
                    if(i < BOARD_SIZE - 3 && j >= 3 &&
                        gameBoard[i][j].color === gameBoard[i+3][j-3].color) {
                        matches.add(`${i+3},${j-3}`);
                        if(i < BOARD_SIZE - 4 && j >= 4 &&
                            gameBoard[i][j].color === gameBoard[i+4][j-4].color) {
                            matches.add(`${i+4},${j-4}`);
                            createSpecialPiece(i, j, 'bomb');
                        } else {
                            createSpecialPiece(i, j, 'star');
                        }
                    }
                }

                // Check shape matches
                if(gameBoard[i][j].shape === gameBoard[i+1][j-1].shape &&
                    gameBoard[i][j].shape === gameBoard[i+2][j-2].shape) {
                    matches.add(`${i},${j}`);
                    matches.add(`${i+1},${j-1}`);
                    matches.add(`${i+2},${j-2}`);
                }
            }
        }

        return Array.from(matches).map(coord => {
            const [row, col] = coord.split(',').map(Number);
            return { row, col };
        });
    }

    // Enhanced findMatches function that tracks match lengths
    function findMatchesWithLength() {
        const matches = new Map(); // Using Map to store match info

        // Helper function to add match to our map with length info
        function addMatch(row, col, matchType, length) {
            const key = `${row},${col}`;
            const existing = matches.get(key) || { row, col, types: new Set(), length: 0 };
            existing.types.add(matchType);
            existing.length = Math.max(existing.length, length);
            matches.set(key, existing);
        }

        // Check horizontal matches
        for(let i = 0; i < BOARD_SIZE; i++) {
            for(let j = 0; j < BOARD_SIZE - 2; j++) {
                // Verify pieces exist before checking
                if (!gameBoard[i] || !gameBoard[i][j] || !gameBoard[i][j+1] || !gameBoard[i][j+2]) continue;

                // Check color matches
                let colorLength = 3;
                if(gameBoard[i][j].color === gameBoard[i][j+1].color &&
                    gameBoard[i][j].color === gameBoard[i][j+2].color) {

                    // Check for longer matches
                    while(j + colorLength < BOARD_SIZE &&
                    gameBoard[i][j + colorLength] && // Add null check
                    gameBoard[i][j].color === gameBoard[i][j+colorLength].color) {
                        colorLength++;
                    }

                    // Add all pieces in the match
                    for(let k = 0; k < colorLength; k++) {
                        addMatch(i, j+k, 'color', colorLength);
                    }
                }

                // Check shape matches
                let shapeLength = 3;
                if(gameBoard[i][j].shape === gameBoard[i][j+1].shape &&
                    gameBoard[i][j].shape === gameBoard[i][j+2].shape) {

                    // Check for longer matches
                    while(j + shapeLength < BOARD_SIZE &&
                    gameBoard[i][j + shapeLength] && // Add null check
                    gameBoard[i][j].shape === gameBoard[i][j+shapeLength].shape) {
                        shapeLength++;
                    }

                    // Add all pieces in the match
                    for(let k = 0; k < shapeLength; k++) {
                        addMatch(i, j+k, 'shape', shapeLength);
                    }
                }
            }
        }

        // Check vertical matches
        for(let j = 0; j < BOARD_SIZE; j++) {
            for(let i = 0; i < BOARD_SIZE - 2; i++) {
                // Verify pieces exist before checking
                if (!gameBoard[i] || !gameBoard[i+1] || !gameBoard[i+2] ||
                    !gameBoard[i][j] || !gameBoard[i+1][j] || !gameBoard[i+2][j]) continue;

                // Check color matches
                let colorLength = 3;
                if(gameBoard[i][j].color === gameBoard[i+1][j].color &&
                    gameBoard[i][j].color === gameBoard[i+2][j].color) {

                    while(i + colorLength < BOARD_SIZE &&
                    gameBoard[i + colorLength] && // Add null check
                    gameBoard[i + colorLength][j] && // Add null check
                    gameBoard[i][j].color === gameBoard[i+colorLength][j].color) {
                        colorLength++;
                    }

                    for(let k = 0; k < colorLength; k++) {
                        addMatch(i+k, j, 'color', colorLength);
                    }
                }

                // Check shape matches
                let shapeLength = 3;
                if(gameBoard[i][j].shape === gameBoard[i+1][j].shape &&
                    gameBoard[i][j].shape === gameBoard[i+2][j].shape) {

                    while(i + shapeLength < BOARD_SIZE &&
                    gameBoard[i + shapeLength] && // Add null check
                    gameBoard[i + shapeLength][j] && // Add null check
                    gameBoard[i][j].shape === gameBoard[i+shapeLength][j].shape) {
                        shapeLength++;
                    }

                    for(let k = 0; k < shapeLength; k++) {
                        addMatch(i+k, j, 'shape', shapeLength);
                    }
                }
            }
        }

        // If chain mode is active, check diagonal and extended matches
        if (chainModeActive) {
            // Check diagonal matches (top-left to bottom-right)
            for(let i = 0; i < BOARD_SIZE - 2; i++) {
                for(let j = 0; j < BOARD_SIZE - 2; j++) {
                    // Verify pieces exist
                    if (!gameBoard[i] || !gameBoard[i+1] || !gameBoard[i+2] ||
                        !gameBoard[i][j] || !gameBoard[i+1][j+1] || !gameBoard[i+2][j+2]) continue;

                    if(gameBoard[i][j].color === gameBoard[i+1][j+1].color &&
                        gameBoard[i][j].color === gameBoard[i+2][j+2].color) {
                        addMatch(i, j, 'color', 3);
                        addMatch(i+1, j+1, 'color', 3);
                        addMatch(i+2, j+2, 'color', 3);
                    }

                    if(gameBoard[i][j].shape === gameBoard[i+1][j+1].shape &&
                        gameBoard[i][j].shape === gameBoard[i+2][j+2].shape) {
                        addMatch(i, j, 'shape', 3);
                        addMatch(i+1, j+1, 'shape', 3);
                        addMatch(i+2, j+2, 'shape', 3);
                    }
                }
            }

            // Check diagonal matches (top-right to bottom-left)
            for(let i = 0; i < BOARD_SIZE - 2; i++) {
                for(let j = 2; j < BOARD_SIZE; j++) {
                    // Verify pieces exist
                    if (!gameBoard[i] || !gameBoard[i+1] || !gameBoard[i+2] ||
                        !gameBoard[i][j] || !gameBoard[i+1][j-1] || !gameBoard[i+2][j-2]) continue;

                    if(gameBoard[i][j].color === gameBoard[i+1][j-1].color &&
                        gameBoard[i][j].color === gameBoard[i+2][j-2].color) {
                        addMatch(i, j, 'color', 3);
                        addMatch(i+1, j-1, 'color', 3);
                        addMatch(i+2, j-2, 'color', 3);
                    }

                    if(gameBoard[i][j].shape === gameBoard[i+1][j-1].shape &&
                        gameBoard[i][j].shape === gameBoard[i+2][j-2].shape) {
                        addMatch(i, j, 'shape', 3);
                        addMatch(i+1, j-1, 'shape', 3);
                        addMatch(i+2, j-2, 'shape', 3);
                    }
                }
            }
        }

        return Array.from(matches.values());
    }

    // Process matches (remove matched pieces and update score)
    // Enhanced processMatches function with new scoring
    function processMatches() {
        const matches = findMatchesWithLength();
        if (matches.length > 0) {
            let totalScore = 0;

            // Process each match
            matches.forEach(match => {
                const { row, col, types, length } = match;
                let matchScore = 0;

                // Base score calculation
                if (types.has('color')) {
                    matchScore += 1; // +1 for color match
                }
                if (types.has('shape')) {
                    matchScore += 1; // +1 for shape match
                }

                // Apply length bonus
                matchScore *= MATCH_BONUSES[Math.min(length, 5)];

                // Apply both-match bonus (3x) if both color and shape matched
                if (types.has('color') && types.has('shape')) {
                    matchScore *= 3;
                }

                // Create score popup with match info
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                const rect = cell.getBoundingClientRect();

                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.style.left = `${rect.left + rect.width/2}px`;
                popup.style.top = `${rect.top + rect.height/2}px`;

                // Show match length for longer matches
                if (length > 3) {
                    popup.textContent = `+${matchScore} (${length}x)`;
                    popup.style.color = types.size > 1 ? '#FFD700' : '#FFFFFF';
                } else {
                    popup.textContent = `+${matchScore}`;
                    popup.style.color = types.size > 1 ? '#FFD700' : '#FFFFFF';
                }

                document.body.appendChild(popup);
                setTimeout(() => popup.remove(), 1000);

                totalScore += matchScore;
            });

            // Apply combo multiplier
            comboCounter++;
            const comboMultiplier = Math.min(2 + (comboCounter * 0.1), 5.0); // Caps at 5x
            totalScore = Math.round(totalScore * comboMultiplier);

            // Update score with combo text
            if (comboCounter > 1) {
                const message = COMBO_MESSAGES[Math.min(comboCounter - 2, COMBO_MESSAGES.length - 1)];
                const comboText = document.createElement('div');
                comboText.className = 'combo-text';
                comboText.textContent = `${message} x${comboMultiplier.toFixed(1)}`;
                comboText.style.top = '50%';
                document.body.appendChild(comboText);

                setTimeout(() => comboText.remove(), 1500);
            }

            // Add chain effect visuals if chain mode is active
            if (chainModeActive && matches.length > 0) {
                matches.forEach((match1, i) => {
                    matches.forEach((match2, j) => {
                        if (i !== j) {
                            const cell1 = document.querySelector(
                                `[data-row="${match1.row}"][data-col="${match1.col}"]`
                            );
                            const cell2 = document.querySelector(
                                `[data-row="${match2.row}"][data-col="${match2.col}"]`
                            );
                            powerupEffects.createChainEffect(cell1, cell2);
                        }
                    });
                });
            }

            // Update score
            updateScore(score + totalScore);

            // Process match removals and cascades
            removeMatches(matches);
            setTimeout(() => {
                dropPieces();
                fillEmptySpaces();
                setTimeout(checkForMatches, 300);
            }, 300);
        } else {
            comboCounter = 0;
        }
    }

    // Remove matched pieces
    function removeMatches() {

        const matches = findMatches();
        matches.forEach(({row, col}) => {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const rect = cell.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // Create particles based on the piece being removed
            particleSystem.burstParticles(
                centerX,
                centerY,
                gameBoard[row][col].color,
                gameBoard[row][col].shape,
                5
            );

            // Add sparkle effect
            particleSystem.createSparkleField(centerX, centerY);

            cell.style.animation = 'explode 0.3s ease-out';
            gameBoard[row][col] = null;
        });
    }

    // Drop pieces after matches are removed
    function dropPieces() {
        for (let col = 0; col < BOARD_SIZE; col++) {
            let emptySpaces = 0;
            for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                if (!gameBoard[row][col]) {
                    emptySpaces++;
                } else if (emptySpaces > 0) {
                    // Move piece down
                    gameBoard[row + emptySpaces][col] = gameBoard[row][col];
                    gameBoard[row][col] = null;

                    // Update visual
                    const cell = document.querySelector(`[data-row="${row + emptySpaces}"][data-col="${col}"]`);
                    cell.innerHTML = '';
                    cell.appendChild(createSVG(gameBoard[row + emptySpaces][col].shape,
                        gameBoard[row + emptySpaces][col].color));
                    cell.classList.add('drop-in');
                }
            }
        }
    }

    // Fill empty spaces with new pieces
    function fillEmptySpaces() {
        for (let i = 0; i < BOARD_SIZE; i++) {
            for (let j = 0; j < BOARD_SIZE; j++) {
                if (!gameBoard[i][j]) {
                    gameBoard[i][j] = {
                        shape: SHAPES[Math.floor(Math.random() * SHAPES.length)],
                        color: COLORS[Math.floor(Math.random() * COLORS.length)]
                    };

                    const cell = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
                    cell.innerHTML = '';
                    cell.appendChild(createSVG(gameBoard[i][j].shape, gameBoard[i][j].color));
                    cell.classList.add('drop-in');

                    setTimeout(() => cell.classList.remove('drop-in'), 500);
                }
            }
        }
    }

    // Check for matches after pieces have dropped
    function checkForMatches() {
        const matches = findMatches();
        if (matches.length > 0) {
            processMatches();
        }
    }

    // Update score and progress
    // Calculate required points for a given level
    function calculateLevelRequirement(level) {
        return BASE_LEVEL_SCORE + ((level - 1) * 100);
    }

    // Enhanced updateScore function
    function updateScore(newScore, fromCombo = false) {
        score = newScore;
        document.getElementById('score').textContent = score;

        // Calculate level progress
        levelProgress = (score / pointsToNextLevel) * 100;
        document.querySelector('.progress-bar').style.width = `${Math.min(100, levelProgress)}%`;

        // Check for level up
        if (score >= pointsToNextLevel) {
            const excessPoints = score - pointsToNextLevel;
            levelUp(excessPoints);
        }

        // Update powerup button state
        document.getElementById('powerupButton').disabled = score < POWERUP_COST;
    }

    // Level up functionality
    // Enhanced levelUp function
    function levelUp(excessPoints = 0) {
        currentLevel++;

        updateLevelDisplay();


        // Show level up message with current level
        const msg = document.createElement('div');
        msg.className = 'level-up-message';
        msg.innerHTML = `
        <div style="font-size: 32px; margin-bottom: 10px;">Level ${currentLevel}!</div>
        <div style="font-size: 18px;">Points needed: ${calculateLevelRequirement(currentLevel)}</div>
    `;
        document.body.appendChild(msg);

        // Create celebration particles
        const rect = msg.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        // Create multiple bursts of particles
        const colors = ['#FFD700', '#FF0000', '#00FF00', '#0000FF'];
        colors.forEach((color, index) => {
            setTimeout(() => {
                particleSystem.burstParticles(centerX, centerY, color, null, 20);
            }, index * 200);
        });

        setTimeout(() => msg.remove(), 2000);

        // Reset score and update point requirement
        pointsToNextLevel = calculateLevelRequirement(currentLevel + 1);
        score = excessPoints; // Carry over excess points to new level

        // Give bonus powerups (respecting MAX_POWERUPS limit)
        const bonusPowerupsCount = Math.min(3, MAX_POWERUPS - powerups.length);
        for(let i = 0; i < bonusPowerupsCount; i++) {
            const randomPowerup = POWERUP_TYPES[Math.floor(Math.random() * POWERUP_TYPES.length)];
            powerups.push({...randomPowerup});
        }
        updatePowerupDock();

        // Update board size if needed
        if (currentLevel <= 4) { // Increase board size up to 12x12
            BOARD_SIZE = Math.min(12, BOARD_SIZE + 1);
        }

        // Reinitialize board with new size
        setTimeout(() => {
            initializeBoard(true); // true flag for explosion animation
        }, 1000);

        // Update UI
        updateScore(score);
    }

    // Add UI elements for level display
    function addLevelDisplay() {
        const scoreContainer = document.querySelector('.score-container');
        const levelDisplay = document.createElement('div');
        levelDisplay.id = 'level-display';
        levelDisplay.style.marginLeft = '20px';
        levelDisplay.innerHTML = `
        <div style="text-align: right;">
            <div>Level: <span id="current-level">1</span></div>
            <div style="font-size: 14px;">Next: <span id="points-needed">${BASE_LEVEL_SCORE}</span></div>
        </div>
    `;
        scoreContainer.appendChild(levelDisplay);
    }

    // Update level display
    function updateLevelDisplay() {
        document.getElementById('current-level').textContent = currentLevel;
        document.getElementById('points-needed').textContent = pointsToNextLevel;
    }

    // Show level up message
    function showLevelUpMessage() {
    const msg = document.createElement('div');
    msg.className = 'level-up-message';
    msg.textContent = 'Level Up!';
    document.body.appendChild(msg);

    // Create celebration particles
    const rect = msg.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Create multiple bursts of particles
    const colors = ['#FFD700', '#FF0000', '#00FF00', '#0000FF'];
    colors.forEach((color, index) => {
        setTimeout(() => {
            particleSystem.burstParticles(centerX, centerY, color, null, 20);
        }, index * 200);
    });

    setTimeout(() => msg.remove(), 2000);
    }

    // Initialize the game
    document.getElementById('readyBtn').addEventListener('click', () => {
        document.getElementById('startMenu').style.display = 'none';
        document.getElementById('gameContainer').style.display = 'block';
        addLevelDisplay(); // Add this line
        initializeBoard();
        createBackgroundEffects();

        // Add starting powerups
        for(let i = 0; i < STARTING_POWERUPS; i++) {
            const randomIndex = Math.floor(Math.random() * POWERUP_TYPES.length);
            powerups.push({...POWERUP_TYPES[randomIndex]});
        }
        updatePowerupDock();
    });

    // Buy powerup button
    document.getElementById('powerupButton').addEventListener('click', () => {
        if (score >= POWERUP_COST) {
            if (powerups.length >= MAX_POWERUPS) {
                alert('Maximum powerups reached! Use some powerups first.');
                return;
            }

            updateScore(score - POWERUP_COST);
            const randomIndex = Math.floor(Math.random() * POWERUP_TYPES.length);
            powerups.push({...POWERUP_TYPES[randomIndex]
            });
            updatePowerupDock();
        }
    });

    // Style powerups based on their type
    function updatePowerupDock() {
        const dock = document.getElementById('powerupDock');
        dock.innerHTML = '';

        powerups.forEach((powerup, index) => {
            const powerupElement = document.createElement('div');
            powerupElement.className = 'powerup-item';
            powerupElement.innerHTML = `
            <div class="powerup-tooltip">${powerup.description}</div>
            <span>${powerup.emoji}</span>
        `;

            // Add specific colors for different powerup types
            switch(powerup.name) {
                case 'Chain Mode':
                    powerupElement.style.color = '#FF4444';
                    break;
                case 'Gold Rush':
                    powerupElement.style.color = '#FFD700';
                    break;
                case 'Rainbow':
                    powerupElement.style.color = '#FF69B4';
                    break;
                case 'Wild Card':
                    powerupElement.style.color = '#4CAF50';
                    break;
                default:
                    powerupElement.style.color = '#FFFFFF';
            }

            powerupElement.addEventListener('click', () => activatePowerup(index));
            dock.appendChild(powerupElement);
        });
    }

    // Helper function to check if a cell can be part of a chain
    // Update canChain function to show visual feedback
    function canChain(cell) {
        const row = parseInt(cell.dataset.row);
        const col = parseInt(cell.dataset.col);

        // Check all 8 directions
        const directions = [
            [-1,-1], [-1,0], [-1,1],
            [0,-1],          [0,1],
            [1,-1],  [1,0],  [1,1]
        ];

        for (const [dx, dy] of directions) {
            const newRow = row + dx;
            const newCol = col + dy;

            if (newRow >= 0 && newRow < BOARD_SIZE &&
                newCol >= 0 && newCol < BOARD_SIZE) {
                if (gameBoard[newRow][newCol].color === gameBoard[row][col].color ||
                    gameBoard[newRow][newCol].shape === gameBoard[row][col].shape) {
                    return true;
                }
            }
        }

        return false;
    }

    // Activate powerup
    function activatePowerup(index) {
        const powerup = powerups[index];
        const powerupElements = document.querySelectorAll('.powerup-item');

        // Remove all active states
        powerupElements.forEach(el => el.classList.remove('powerup-active'));
        document.querySelectorAll('.cell').forEach(cell => {
            cell.className = 'cell';
            cell.style.cursor = 'pointer';
        });

        if (activePowerup === powerup) {
            activePowerup = null;
            removeEffectOverlay();
        } else {
            activePowerup = powerup;
            powerupElements[index].classList.add('powerup-active');

            // Add powerup-specific effects
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                switch(powerup.name) {
                    case 'Chain Mode':
                        if (canChain(cell)) {
                            cell.classList.add('cell-targetable', 'cell-chain-ready');
                        }
                        break;

                    case 'Gold Rush':
                        cell.classList.add('cell-gold-rush');
                        break;

                    case 'Rainbow':
                        cell.classList.add('cell-rainbow');
                        break;

                    case 'Shuffle':
                        cell.classList.add('cell-shuffle');
                        break;

                    case 'Wild Card':
                        cell.classList.add('cell-targetable', 'cell-wild-card');
                        break;

                    default:
                        cell.classList.add('cell-targetable');
                }
            });

            // Create activation particles
            const element = powerupElements[index];
            const rect = element.getBoundingClientRect();
            createActivationEffect(rect, powerup.name);
        }
    }

    // Create activation effect based on powerup type
    function createActivationEffect(rect, powerupType) {
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        switch(powerupType) {
            case 'Chain Mode':
                // Create chain link particles in a circle
                for(let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = centerX + Math.cos(angle) * 30;
                    const y = centerY + Math.sin(angle) * 30;
                    particleSystem.createParticle(x, y, '#FF4444', '‚õìÔ∏è');
                }
                break;

            case 'Gold Rush':
                // Create gold coin burst
                particleSystem.burstParticles(centerX, centerY, '#FFD700', 'üí∞', 12);
                break;

            case 'Rainbow':
                // Create rainbow particles in arc
                const colors = ['#FF0000', '#FFA500', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];
                colors.forEach((color, i) => {
                    setTimeout(() => {
                        particleSystem.createParticle(centerX, centerY, color, null);
                    }, i * 100);
                });
                break;

            case 'Shuffle':
                // Create rotating card particles
                for(let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        particleSystem.createParticle(centerX, centerY, '#FFFFFF', 'üîÑ');
                    }, i * 150);
                }
                break;

            case 'Wild Card':
                // Create wild card burst
                particleSystem.burstParticles(centerX, centerY, '#4CAF50', 'üÉè', 8);
                break;

            default:
                // Default particle burst
                particleSystem.burstParticles(centerX, centerY, '#FFFFFF', null, 10);
        }
    }

    // Helper function to remove effect overlay
    function removeEffectOverlay() {
        const overlay = document.querySelector('.powerup-effect-overlay');
        if (overlay) {
            overlay.remove();
        }
    }

    // Remove powerup after use
    function removePowerup(powerup) {
        const index = powerups.indexOf(powerup);
        if (index > -1) {
            powerups.splice(index, 1);
            updatePowerupDock();
        }
    }

    // Replace a single block
    function replaceBlock(row, col) {
        gameBoard[row][col] = {
            shape: SHAPES[Math.floor(Math.random() * SHAPES.length)],
            color: COLORS[Math.floor(Math.random() * COLORS.length)]
        };

        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        cell.innerHTML = '';
        cell.appendChild(createSVG(gameBoard[row][col].shape, gameBoard[row][col].color));
        cell.classList.add('drop-in');
        setTimeout(() => cell.classList.remove('drop-in'), 500);
    }

    // Create background effects
    function createBackgroundEffects() {
        const container = document.createElement('div');
        container.className = 'background-effect';

        // Add particles
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.top = Math.random() * 100 + '%';
            particle.style.animationDuration = 2 + Math.random() * 3 + 's';
            particle.style.animationDelay = Math.random() * 2 + 's';
            container.appendChild(particle);
        }

        document.body.appendChild(container);
    }

    // Initialize background effects when game starts
    document.getElementById('readyBtn').addEventListener('click', () => {
        createBackgroundEffects();
    });

    // Initialize score tracking
    updateScore(0);

    // Handle window resize
    window.addEventListener('resize', () => {
        const cells = document.querySelectorAll('.cell');
        const size = Math.min(
            (window.innerWidth - 40) / BOARD_SIZE,
            (window.innerHeight - 200) / BOARD_SIZE
        );
        cells.forEach(cell => {
            cell.style.width = size + 'px';
            cell.style.height = size + 'px';
        });
    });
</script>
</body>

</html>